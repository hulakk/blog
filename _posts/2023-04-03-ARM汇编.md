---
layout: post
title:  ARM汇编基础
categories: 汇编
tags: 计算机 CS 汇编 嵌入式系统
comments: true
---

## 整体框架
```asm
;文件名：TEST1.S 
;功能：实现两个寄存器相加 
;说明：使用ARMulate软件仿真调试 
        AREA	Example1,CODE,READONLY	  ;声明代码段Example1 
        ENTRY				  ;标识程序入口 
        CODE32				  ;声明32位ARM指令
START 	MOV	R0,#0			  ;设置参数 
 	    MOV	R1,#10
LOOP	BL	ADD_SUB	    	  ;调用子程序ADD_SUB 
	    B	LOOP			  ;跳转到LOOP
ADD_SUB	 
        ADDS	R0,R0,R1      ;R0 = R0 + R1 
        MOV	PC,LR             ;子程序返回 
        END                   ;文件结束 
```  
说明：
1.注释以“;”开头  
2.标号（以上代码中的“START”“LOOP”“ADD_SUB”）定格写  
3.以“END”结尾  
4.尖括号（“<>”）包含的内容是必须的，花括号（“{}”）包含的内容是可选的  

## 单条指令格式
```asm
<opcode>    {<cond>}     {S}                    <Rd>        ,<Rn>                   {,<operand2>} 
<指令助记符> {<执行条件>} {是否影响CPSR寄存器的值} <目标寄存器> ,<第一个操作数的寄存器>   {,<第二个操作数>}
```  

## \<operand2\> 第二个操作数
\<operand2\>有如下三种形式：  
- 常数表达式形式  
- 寄存器形式  
- 寄存器移位形式  

### 常数表达式形式（#immed_8r）
**该常数必须对应8位位图，即必须是一个8位的常数通过循环右移偶数位可以得到的数。**  
移位前：`00000000 00000000 00000000 xxxxxxxx`  
将这个32位数（除了最后8位都是0）向右循环移位任意偶数位（但要在1轮以内），即得到一个新的32位数（称为`8位图立即数`），**将这个32位二进制数写入汇编代码中**。  
这样，新的32位数就可以用`8位数值位`和`4位移位数`组成的12位二进制编码表示。由于用12位二进制编码来表示32位二进制数，因此有些32位二进制数无法被表示。  

参考资料：[CSDN](https://blog.csdn.net/harrymore2011/article/details/6657927)  

### 寄存器形式
在寄存器方式下，操作数即为寄存器的数值。  
### 寄存器移位方式
将寄存器的移位结果作为操作数，但所提到的寄存器本身的值保持不变。  
移位方式：  

|操作码|说明|
|----- |---|
|ASR #n |算术右移n位|
|LSL #n |逻辑左移n位|
|LSR #n |逻辑右移n位|
|ROR #n |循环右移n位|
|RRX    |带扩展的循环右移1位|
|Type Rs|Type为移位的一种类型，Rs为偏移量寄存器，低8位有效|  

示例：  
```asm
ADD	R1,R1,R1,LSL #3	;R1=R1+R1*8=9R1 ;“R1,LSL # 3”为一个整体
SUB	R1,R1,R2,LSR R3	;R1=R1-(R2/2^R3) ;“R2,LSR R3”为一个整体
```  

## <cond> 条件码
绝大部分的ARM指令都可以条件执行，而Thumb指令只有B（跳转）指令具有条件执行 功能。如果指令不标明条件代码，将默认为无条件（AL）执行。  

|操作码|条件助记符|标志|含义|
|:-----|:----------|:----|:---|
|0|EQ|Z=1|相等|
|1|NE|Z=0|不相等|
|10|CS/HS|C=1|无符号数大于或等于|
|11|CC/LO|C=0|无符号数小于|
|100|MI|N=1|负数|
|101|PL|N=0|正数或零|
|110|VS|V=1|溢出|
|111|VC|V=0|没有溢出|
|1000|HI|C=1|Z=0|无符号数大于|
|1001|LS|C=0|Z=1|无符号数小于或等于|
|1010|GE|N=V|有符号数大于或等于|
|1011|LT|N!=V|有符号数小于| 
|1100|GT|Z=0|N=V|有符号数大于|
|1101|LE|Z=1|N!=V|有符号数小于或等于| 
|1110|AL|任何|无条件执行(指令默认条件)| 
|1111|NV|任何|从不执行(不要使用)|   

## ARM指令种类
- 存储器访问指令  
- 数据处理指令  
- 乘法指令  
- ARM分支指令  
- 协处理器指令  
- 杂项指令  
- 伪指令  

### 存储器访问指令
ARM处理器是典型的RISC处理器，对存储器的访问只能使用加载和存储指令实现。  
存储器访问指令分为单寄存器操作指令和多寄存器操作指令。  
`LDR`/`STR`指令用于对内存变量的访问、内存缓冲区数据的访问、查表、外围部件的控制操作等。若使用`LDR`指令加载数据到PC寄存器，则实现程序跳转功能，这样也就实现了程序散转。  

#### 单寄存器
所有单寄存器加载/存储指令可分为“**字和无符号字节加载存储指令**”和“**半字和有符号字节加载存储指令**”。  
```asm
LDR <目标寄存器>,<源地址>   ;装载指令(存储器->寄存器)
STR <源寄存器>,<目标地址>   ;存储指令(寄存器->存储器)
```  
LDR/STR指令搭配不同的后缀实现不同方式的单寄存器存取操作:  

|助记符|说明|操作|条件码位置|
|:----|:---|:---|:--------|
|LDR Rd,addressing |加载字数据|Rd←[addressing],addressing索引|LDR{cond}|
|LDRB Rd,addressing|加载无符号字节数据|Rd←[addressing],addressing索引|LDR{cond}B|
|LDRT Rd,addressing|以用户模式加载字数据|Rd←[addressing],addressing索引|LDR{cond}T|
|LDRBT Rd,addressing|以用户模式加载无符号|Rd←[addressing],addressing索引|LDR{cond}BT|
|LDRH Rd,addressing|加载无符号半字数据|Rd←[addressing],addressing索引|LDR{cond}H|
|LDRSB Rd,addressing|加载有符号字节数据|Rd←[addressing],addressing索引|LDR{cond}SB|
|LDRSH Rd,addressing|加载有符号半字数据|Rd←[addressing],addressing索引|LDR{cond}SH|  

|助记符|说明|操作|条件码位置|
|:----|:---|:---|:--------|
|STR Rd,addressing|存储字数据|[addressing]←Rd,addressing索引|STR{cond}|
|STRB Rd,addressing|存储字节数据|[addressing]←Rd,addressing索引|STR{cond}B|
|STRT Rd,addressing|以用户模式存储字数据|[addressing]←Rd,addressing索引|STR{cond}T|
|STRBT Rd,addressing|以用户模式存储字节数据|[addressing]←Rd,addressing索引|STR{cond}BT|
|STRH Rd,addressing|存储半字数据|[addressing]←Rd,addressing索引|STR{cond}H|

规律：  
1. 有`B`为“字节”数据，有`H`的是“半字”数据，都没有则为“字”数据  
2. 有`T`则以用户模式加载/存储，否则以特权模式加载/存储  
3. 有`S`则为有符号数据，否则为无符号数据  
4. `LDR`/`STR`最前，条件码在中，后缀在后  

#### 多寄存器
多寄存器加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数据。LDM为加载多个寄存器；STM为存储多个寄存器。允许一条指令传送16个寄存器的任何子集或所有寄存器。它们主要用于现场保护、数据复制、常数传递等。  
```asm
LDM <源地址>,<目标寄存器列表>   ;装载指令(存储器->寄存器)
STM <目标地址>,<源寄存器列表>  ;存储指令(寄存器->存储器)
```  
LDM/STM指令搭配不同的后缀实现不同方式地址增长方式：  
- IA： 每次传送后地址加4
- IB： 每次传送前地址加4
- DA：每次传送后地址减4
- DB：每次传送前地址减4
